# 进程 vs. 线程
# 多进程和多线程，这是实现多任务最常用的两种方式

# Master-Worker模式: 一个Master负责分配任务，多个Worker负责执行任务
	# 用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker
	# 用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker
	
# 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程
# 著名的Apache最早就是采用多进程模式

# 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大
# 操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题

# 多线程模式通常比多进程快一点点！！
# 多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存
# 在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式
# 由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。


## 线程切换：无论是多进程还是多线程，只要数量一多，效率肯定上不去：“切换有代价”


## 计算密集型 vs. IO密集型
	# 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力
	# 最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数
	# 计算密集型任务，最好用C语言编写
	
	# IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务
	# CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）
	# 对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用
	# 对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。
	# 用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率

	
## 异步IO 
	# 现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO
	# 用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型
	# Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务
	# 异步IO编程模型来实现多任务
	# 单进程的异步编程模型称为 “协程”，有了协程的支持，就可以基于事件驱动编写高效的多任务程序
	