#C语言接口与实现-创建可重用软件的技术 -- David R. Hanson 傅蓉译
英文名：C Interfaces and Implementations Techniques for Creating Reusable Software

这本书阐述了如何用一种与语言无关的方法将接口的设计与实现独立开来，从而形成一种基于接口的设计途径来创建可重用的API。

可重用软件模块是构建大规模、可靠应用的基石。

这本书共20章，每一章都有一个接口的完整实现，接口的抽象，封装，接口的底层实现。代码风格不用说了，界面非常简单，实现算法
都是非常优雅的，但是有些不足，就是变量的命名风格，不是很完美，和代码大全所建议的区别很大。

第17章 扩展精度算法(XP extend precision)

	这是遇到的第一个，其实现让我看得头晕的接口--XP接口，本质就是一个大数存储接口，任意大整型数的存储。
	实现方法，很普通就是字符数组，优化的地方，在于其基础取的是256(1<<8)，实现尽可能节省存储空间。
	封装了普通整型数的基本操作，加、减、乘、除、左移、右移、取反、取补码、比较等。
	还有字符串与整数之间的相互转换函数。
	
	加法：实现非常巧妙，carry参数实现进位，和小学数学中，学习的竖式加法完全相同。
	减法：也是数学书中的，竖式减法的实现，borrow参数实现借位。
	乘法：还是数学书中的，竖式乘法的实现，多位数乘多位数有点混，关键是理解单个位与位乘时，
		数字的最低位起点的位置得理解好，10进制的理解，就是末尾添加几个0，然后处理好进位问题，
		即变成一位数乘法了。
	除法：最复杂的实现，就是除法实现算法，看着头晕。除数是一位数的时候，比较容易理解，竖式除法，
		但是多位除数的时候，太绕了。
	左移、右移勉强可以理解，因为所有的进制数，只是展示给人看的时候，不一样，但是，在计算机里面，
	都是二进制数(0,1)存储的，对于位操作，刚好就是对二进制位的操作，如此转换理解，二进制操作，就轻松多了。

第20章 线程(Thread)
	
	这一章，第一感觉是最复杂的，但是看接口的时候，感觉还是很通俗易懂的，对于线程，我一直非常陌生，对于生疏的东西，潜意识害怕，
	操作系统，体系结构都没有学好，书也是匆匆而过，没有巩固。但是看着这章，关于线程基础的讲解，信号量，互斥信号量，同步的解释，
	很有收获，以前学的知识，零零散散的聚起来了，也可以理解。但是看到实现的时候，才发现太难了，其一，逻辑复杂，其二，太底层了，
	使用了汇编语言，又是不熟悉的。
	
	线程的实现，thread和semaphore一起实现的，又是锁机制，临界区访问，异常等，实在是难以理解啊。
	
	其实大概逻辑好像也可以明白，同步，必须处理好临界区共享问题。复杂的东西，其实就是线程结构的定义，成员标记太多了，其实质还是
	一个结构，存储需要存储的信息而已，然后在需要的时候，读取信息。
	第一步，把需要的信息记录好，压栈；第二步，需要什么信息的时候，从结构中去取。(保护现场，恢复现场)

	**线程控制块--线程句柄(线程控制模块)** 记录所需信息，然后按照需要解析，自然即可实现线程接口实现了。
	
	线程切换的本质，就是堆栈指针的切换，或者说程序计数器的地址改变。
	
	技巧，使用结构封装函数参数，直接使用一个结构指针，即可记录所有的参数信息，使用起来，更加简单，小巧，避免调用函数参数太多。
	struct args{...};
	
这本书的接口很多，多数还是比较简单，实现很好理解的。这本书主要的还是这种接口抽象的技巧，非常漂亮。接口抽象的非常小巧，实用，
和面向对象编程的思路基本上一样了，只是没有封装而已。但是其一致性方面，都是很完美的抽象。

书的唯一不足，是变量命名，不够合理规范。但是函数的命名非常规范合理，一直子程序完成一个目的，非常清晰。也实现了异常处理机制，
鲁棒性也非常好，断言(assert)专门检测输入参数非法的，运行时错误。

####Date
开始日期：**2016-03-29**

结束时间：**2016-04-20**

前前后后，零零散散，也花了快一个月的时间，看书速度还是可以的，以前总是以为一本书，没有半年，一年是看不完的。其一，琐事比较多，其二，天性贪玩，
很难坚持一直做一件事情，其三，贪心不足，所以即喜欢看这书，又喜欢看那书，总是左看看右看看，耽误了很多时间。

现在树立目标，同时看书数，不超过三本，最好两本，一本书太枯燥乏味的时候，就难以坚持，两本书可以相互激励。当然了，这是指专业课的书，需要大量
理解，记忆的，看着很无趣，看完，收获很多，成就感也足。加油！

####阅读感想
1. &(*p)和p的区别
	
	&(*p) 是一个右值，p是一个左值
	右值的含义是:这个值不能用某个内存空间来间接表示，
	&(*p)仅仅是个地址数值，它不存于任何内存空间中，不能修改它。
	
	&(*p)->getMember，可以，但是不能赋值
	p->getMember，可以，p = q，也可以。
	
2. 隐式指针

	typedef T *T;
	
	
这本书草草的看完了一遍，收获说不出来，肯定多c语言理解更加深刻吧，知道怎么完成C语言接口和重用技术的编程了。全书使用的新技巧，其实不多，
多数见过，就线程接口的创建比较陌生，当然了除法原理也不是很清楚。其他的接口，主要是完成一个抽象过程，使得接口界面美如画。

理解的东西，以前也差不多知道，但是自己肯定写不出来，所以等价于更深刻的复习了一遍，不理解的，还是没有搞懂，属于个人懒惰，不愿意钻研，
而又贪心太多，总希望看更新的书，一本新书，给我的感觉我收获更多，因为我就是一块无知的海绵，吸收各种颜色的染料，新的颜色往往更加艳丽，
显眼，老颜色添加多少，只会加深，效果不明显，所以这样了。任性啊！

不知道这是不是好习惯，但是我总会回来再看的，如果我有大把的时间。
